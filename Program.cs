/// <summary>
/// Program.cs - 潜水艇游戏的主程序入口文件
/// 
/// 【C# 9.0 新特性 - Top-level statements】:
/// - 从C# 9.0开始，可以直接在文件顶层写可执行代码
/// - 不需要显式定义Main方法和Program类
/// - 编译器会自动生成Program类和Main方法
/// - 简化了简单程序的代码结构
/// 
/// 【程序执行流程】:
/// 1. 引入必要的命名空间
/// 2. 创建游戏棋盘对象
/// 3. 进入游戏主循环
/// 4. 循环处理用户输入和游戏显示
/// 5. 检查游戏结束条件并退出
/// 
/// 【设计模式】:
/// - 游戏循环模式：持续处理输入->更新->显示的循环
/// - 这是游戏开发中最基本的设计模式之一
/// </summary>

using System;
using submarine;

// 【对象创建和初始化】
// 使用Program类中定义的常量来创建Board对象
// 这体现了常量复用的好处：如果要改变棋盘大小，只需修改一处
Board board = new Board(Program.ROW_SIZE, Program.COLUMN_SIZE);

// 【游戏主循环 - Game Loop】
// while(true) 创建一个无限循环
// 这是游戏程序的核心结构：持续运行直到满足退出条件
while (true)
{
    // 【输入阶段 - Input Phase】
    // 处理玩家输入，获取玩家选择的位置坐标
    // 这个方法会：
    // 1. 提示用户输入
    // 2. 读取用户输入
    // 3. 验证和转换输入
    // 4. 更新游戏状态
    board.Input();
    
    // 【输出阶段 - Output Phase】
    // 显示当前游戏状态，包括：
    // 1. 棋盘当前状态
    // 2. 玩家选择的历史记录  
    // 3. 距离提示或胜利信息
    // 4. 其他游戏反馈信息
    board.Print();
    
    // 【游戏状态检查 - Game State Check】
    // 检查游戏是否应该结束
    // 如果玩家击中潜水艇，IsFinished()返回true
    if (board.IsFinished())
    {
        // 【循环退出 - Loop Exit】
        // break语句跳出while循环
        // 程序将继续执行循环后的代码（如果有）
        // 在这个程序中，break后程序就结束了
        break;
    }
    
    // 【循环继续】
    // 如果游戏没有结束，程序会回到while循环的开始
    // 继续下一轮的 输入->显示->检查 循环
}

// 【程序结束】
// 当break执行后，程序会到达这里
// 由于没有更多代码，程序会正常结束
// 在更复杂的程序中，这里可能会有清理资源的代码

/// <summary>
/// Program类的部分定义 - 存储游戏的全局常量
/// 
/// 【partial class概念】:
/// - partial关键字允许将一个类的定义分散到多个文件中
/// - 编译时，编译器会将所有partial部分合并为一个完整的类
/// - 这在大型项目中很有用，可以将类的不同功能分散到不同文件
/// 
/// 【为什么使用partial class】:
/// - 在这个项目中，主要是为了演示这个语言特性
/// - 实际项目中，可能用于代码生成、团队协作等场景
/// - 例如：Visual Studio的设计器生成的代码通常放在.Designer.cs文件中
/// 
/// 【常量定义的最佳实践】:
/// - 使用const关键字定义编译时常量
/// - 常量名使用大写字母和下划线分隔（如ROW_SIZE）
/// - 将相关常量组织在一起，便于维护
/// - 常量应该有明确的含义和合适的命名
/// </summary>
// 5 個の会話
partial class Program
{
    /// <summary>
    /// 游戏棋盘的行数常量
    /// 
    /// 【const关键字】:
    /// - const声明编译时常量，值在编译期确定
    /// - 常量值会直接嵌入到使用它的代码中
    /// - 性能高，但修改后需要重新编译所有引用代码
    /// 
    /// 【为什么选择9行】:
    /// - 9x9是经典的游戏棋盘尺寸
    /// - 提供合适的游戏难度和复杂度
    /// - 便于在控制台中显示完整棋盘
    /// 
    /// 【设计考虑】:
    /// - 如果要支持不同难度，可以考虑使用static readonly
    /// - 或者通过配置文件、用户输入等方式动态设置
    /// </summary>
    public const int ROW_SIZE = 9;
    
    /// <summary>
    /// 游戏棋盘的列数常量
    /// 
    /// 【为什么行数和列数相等】:
    /// - 方形棋盘在视觉上更平衡
    /// - 简化了游戏逻辑和算法
    /// - 符合大多数用户对棋盘游戏的预期
    /// 
    /// 【扩展性考虑】:
    /// - 当前设计支持方形棋盘
    /// - 如果需要支持矩形棋盘，这种设计已经提供了基础
    /// - Position类和Board类都支持不同的行列数
    /// </summary>
    public const int COLUMN_SIZE = 9;
}

/// <summary>
/// 【程序架构总结】:
/// 
/// 1. **分层架构**:
///    - Program层：程序入口和游戏循环控制
///    - Board层：游戏逻辑和状态管理  
///    - Position层：数据结构和工具方法
/// 
/// 2. **设计原则应用**:
///    - 单一职责：每个类都有明确的职责
///    - 开闭原则：通过常量配置支持扩展
///    - 封装性：私有字段保护内部状态
/// 
/// 3. **C#特性使用**:
///    - Top-level statements：简化程序结构
///    - Partial class：演示类定义分离
///    - 结构体：高效的值类型数据结构
///    - 枚举：类型安全的常量组
///    - 属性：受控的数据访问
/// 
/// 4. **游戏循环模式**:
///    - Input：处理用户输入
///    - Update：更新游戏状态
///    - Render：显示游戏画面
///    - Check：检查游戏条件
/// 
/// 这个程序是学习C#编程和游戏开发基础概念的良好示例。
/// </summary>